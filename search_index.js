var documenterSearchIndex = {"docs":
[{"location":"opts/#Callisto.Opts-module","page":"Callisto.Opts module","title":"Callisto.Opts module","text":"","category":"section"},{"location":"opts/","page":"Callisto.Opts module","title":"Callisto.Opts module","text":"CurrentModule = Callisto.Opts","category":"page"},{"location":"opts/","page":"Callisto.Opts module","title":"Callisto.Opts module","text":"Link\nCalOpts\nCalOpts()\nmake_ugn(beta0, gear, latency, theta0_at_src,  wm2_at_src, theta0_at_dst)","category":"page"},{"location":"opts/#Callisto.Opts.Link","page":"Callisto.Opts module","title":"Callisto.Opts.Link","text":"Link structure\n\n\n\n\n\n","category":"type"},{"location":"opts/#Callisto.Opts.CalOpts","page":"Callisto.Opts module","title":"Callisto.Opts.CalOpts","text":"CalOpts structure\n\n\n\n\n\n","category":"type"},{"location":"opts/#Callisto.Opts.CalOpts-Tuple{}","page":"Callisto.Opts module","title":"Callisto.Opts.CalOpts","text":"CalOpts(;)\n\nReturn a CalOpts structure. Keyword arguments are:\n\ngraph    latency\n\n\n\n\n\n","category":"method"},{"location":"opts/#Callisto.Opts.make_ugn-NTuple{6, Any}","page":"Callisto.Opts module","title":"Callisto.Opts.make_ugn","text":"a tuplmake_ugn(beta0, gear, latency, theta0_at_src,  wm2_at_src, theta0_at_dst)\n\nCompute the value for the UGN of a particular link, given\n\nbeta0: the initial occupancy of the elastic buffer at the destination\ngear: the gear ratio of the link, that is the number of frames sent per source clock tick\nlatency: the time taken for a frame to traverse the link\ntheta0_at_src: the value of the clock phase at time 0 at the source end of the link\nwm2_at_src: the clock frequency at the source end of the link for times < 0\ntheta0_at_dst: the value of the clock phase at time 0 at the destination end of the link\n\n\n\n\n\n","category":"method"},{"location":"opts/#Index","page":"Callisto.Opts module","title":"Index","text":"","category":"section"},{"location":"opts/","page":"Callisto.Opts module","title":"Callisto.Opts module","text":"","category":"page"},{"location":"#Callisto.jl","page":"Callisto.jl","title":"Callisto.jl","text":"","category":"section"},{"location":"#Introduction","page":"Callisto.jl","title":"Introduction","text":"","category":"section"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"Callisto.jl is a simulator for bittide, a system architecture for synchronous distributed computing.  A detailed description of the bittide mechanism is available in the papers:","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"S. Lall, C. Cascaval, M. Izzard and T. Spalink. Modeling and Control of bittide Synchronization.  Proceedings of the American Control Conference, 2022. arXiv:2109.14111\nS. Lall, C. Cascaval, M. Izzard and T. Spalink. Resistance Distance and\tControl Performance for bittide Synchronization. Proceedings of the European Control Conference, 2022. arXiv:2111.05296","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"The model and algorithm used by Callisto follows closely that described in the first of these papers. ","category":"page"},{"location":"#Resources","page":"Callisto.jl","title":"Resources","text":"","category":"section"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"The source code for Callisto\nThe documentation\nThe CallistoVisualization package\nThe PlotKit package","category":"page"},{"location":"#Installation","page":"Callisto.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"Start Julia, and at the REPL prompt install Callisto as follows.","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/bittide/Callisto.jl\")","category":"page"},{"location":"#Quickstart","page":"Callisto.jl","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"Now you can run a simple simulation:","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"julia> using Callisto\njulia> c = CalOpts()\njulia> x = callisto(c)","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"You can view the output:","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"julia> xc = parse_callisto_logx(c, x...)\njulia> using PlotKit\njulia> pzip(a) = Point.(zip(a.x, a.y))\njulia> save(drawplot(pzip.(xc.freq)), \"frequency.png\")","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"This will save a plot of the frequency against time in the file frequency.png in  the Julia working directory.","category":"page"},{"location":"#Common-options","page":"Callisto.jl","title":"Common options","text":"","category":"section"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"julia> c = CalOpts(; kwargs...)","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"CalOpts takes a number of optional keyword arguments. These include","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"topology: a tuple, whose first entry is the string name, and remaining  entries are numerical parameters. For example,\n(\"triangle\")\n(\"mesh\", 3, 4)\n(\"line\", 6)\nkp: proportional gain\nki: integral gain\nlatency: either a number, in which case it is the latency of every link,  or a list, whose ith entry is the latency of the ith link\ntmax: simulation end time\npoll_period: the delay, in localticks, between successive control updates\ncontrol_delay: the delay, in localticks, at a node between making a measurement  and the frequency update\nerrors: a list of the uncontrolled frequency of the oscillators\nbase_freq: used to scale the integrator in the controller. See the example below.","category":"page"},{"location":"#Example","page":"Callisto.jl","title":"Example","text":"","category":"section"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"The following is a more complete example. In particular, here we are setting the uncontrolled frequencies of the system to be approximately 200MHz, with a maximum error of 100ppm. ","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"We are also running the system in units of nanoseconds, so 200MHz corresponds to a frequency of 0.2.  The sampling period of the controller is given by poll_period, but this is in units of localticks. Because sampling is driven by the local clock, it can only be set in localticks. The variable typical_freq contains the approximate frequency of the oscillators. Here we scale poll_period by the typical frequency so that the sampling rate is about 1e5 nanoseconds.","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"The base_freq option to CalOpts is used by the controller. Because we are using a PI controller, setting the base_freq is important. In the PI controller, the integral is approximated by a running sum scaled by 1/base_freq. We set base_freq equal to typical_freq for this approximation.","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"module Run\n\nusing Callisto\nusing PlotKit\nusing Random\n\nplotpath(x) = joinpath(ENV[\"HOME\"], \"plots/\", x)\npzip(a) = Point.(a)\ntzip(a::Series) = pzip(tuples(a))\ntzip(a::Array)  = pzip.(tuples.(a))\nplot(d, f; kw...) = save(drawplot(tzip(d); kw...), plotpath(f), 4)\n\nfunction main()\n    tmax = 2e8\n    num_nodes = 6\n    typical_freq = 0.2 # GHz\n    max_ppm = 100\n    Random.seed!(1)\n    freqs = typical_freq * (1 .+  rand(-max_ppm:max_ppm, num_nodes) /  1e6)\n    errors =  [Error(a) for a in freqs]\n    c = CalOpts(; topology=(\"mesh\", 3, 2),\n                ki = 1e-15,\n                kp = 2e-8,\n                latency = 200,     \n                control_delay = 10,\n                poll_period = 1e5 * typical_freq,\n                base_freq = typical_freq,\n                tmax,\n                errors)\n    x = callisto(c)\n    make_plots(c, x)\nend\n\n\nfunction make_plots(c, x)\n    xc = parse_callisto_logx(c, x...)\n    \n    plot(xc.freq, \"ex_frequency.png\")\n    plot(xc.freq, \"ex_frequency_detail.png\", xmin=0, xmax = 1e7; xidealnumlabels = 6)\n    plot(xc.mocc, \"ex_measured_occupancy.png\")\n\n    fc = focused_callisto_info(c, xc, 180e6, 180e6 + 50)\n    plot(fc.occ, \"ex_occupancy_detail.png\"; xidealnumlabels = 6)\nend\n\nend","category":"page"},{"location":"#Output","page":"Callisto.jl","title":"Output","text":"","category":"section"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"Calling callisto returns a Log object, and theta, which is a list of PiecewiseLinear objects, one for each node. There are two convenience functions for parsing this data. The first is parse_callisto_logx, used as follows.","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"julia> c = CalOpts()\njulia> simlog, theta = callisto(c)\njulia> xc = parse_callisto_logx(c, simlog, theta)","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"The return value is a named tuple, containing fields:","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"simlog: the Log object\ntheta: the phase of each node\nfreq: the frequency of each node\nmeas: the measurement at each node\nafreq: the adjusted frequency at each node\nxi: the first controller state at each node\nmocc: the measured buffer occupancy at each edge","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"Each of these is a list of quantities, which are either PiecewiseLinear, PiecewiseConstant or Samples objects. One important point is that mocc only contains samples of the occupancy at the sample times, that is, every poll_period localticks. In fact, the buffer occupancy changes in between these sample instants. To see the buffer occupancy at all times, one can use focused_callisto_info, as follows","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"julia> tmin = 180e6\njulia> tmax = tmin + 50\njulia> fc = focused_callisto_info(c, xc, tmin, tmax)","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"The return value here is a named tuple, with two fields:","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"occ: the occupancy of each elastic buffer\nadj_theta: the adjusted theta values","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"The field occ is PiecewiseConstant, containing the exact buffer occupancy of the elastic buffer, including every frame arrival and departure. As a result, it can be very large if tmax - tmin is large.","category":"page"},{"location":"#Plotting","page":"Callisto.jl","title":"Plotting","text":"","category":"section"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"The PiecewiseLinear, PiecewiseConstant or Samples objects each have a method tuples, which converts the object into a list of tuples (x,y) suitable for passing to your favorite plotting package, for example:","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"plottable_data = tuples.(xc.freq)","category":"page"},{"location":"","page":"Callisto.jl","title":"Callisto.jl","text":"where we have used broadcast . notation to apply the function tuples to each entry of xc.freq.","category":"page"},{"location":"piecewise/#Callisto.Piecewise-module","page":"Callisto.Piecewise module","title":"Callisto.Piecewise module","text":"","category":"section"},{"location":"piecewise/","page":"Callisto.Piecewise module","title":"Callisto.Piecewise module","text":"CurrentModule = Callisto.Piecewise","category":"page"},{"location":"piecewise/","page":"Callisto.Piecewise module","title":"Callisto.Piecewise module","text":"is_increasing(x)","category":"page"},{"location":"piecewise/#Callisto.Piecewise.is_increasing-Tuple{Any}","page":"Callisto.Piecewise module","title":"Callisto.Piecewise.is_increasing","text":"is_increasing(x)\n\nReturn true if x[i-1] < x[i] for all i=2...length(x).\n\n\n\n\n\n","category":"method"},{"location":"piecewise/#Index","page":"Callisto.Piecewise module","title":"Index","text":"","category":"section"},{"location":"piecewise/","page":"Callisto.Piecewise module","title":"Callisto.Piecewise module","text":"","category":"page"}]
}
